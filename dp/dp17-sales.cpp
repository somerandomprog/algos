#include <fstream>
#include <vector>
#include <algorithm>
#include <limits>
#include <unordered_map>
using namespace std;

#define V vector
// –Ω–µ–¥–æ—Å—Ç–∏–∂–∏–º–æ–µ —á–∏—Å–ª–æ –ø—Ä–∏ —Ä–∞—Å—Å—á—ë—Ç–µ —Ü–µ–Ω—ã
#define MAX numeric_limits<int>::max()
#define FOR(x, y) for(int x = 0; x <= y; x++)
// —Å–∫–æ–ª—å–∫–æ –º—ã —Ö–æ—Ç–∏–º –∫—É–ø–∏—Ç—å i-–æ–≥–æ –ø—Ä–æ–¥—É–∫—Ç–∞
#define PAMOUNT(i) products[i].amount
// —Å–∫–æ–ª—å–∫–æ —Ç—Ä–µ–±—É–µ—Ç—Å—è –∫—É–ø–∏—Ç—å j-–æ–≥–æ —á—Ç–æ–±—ã –ø—Ä–∏–º–µ–Ω–∏—Ç—å i-—É—é —Å–∫–∏–¥–∫—É
#define SAMOUNT(j) sales[i].amounts[j]

struct Product
{
	int id;
	int cost;
	int amount;
};

struct Sale {
	// –≤ —ç—Ç–æ–º –º–∞—Å—Å–∏–≤–µ –í–°–ï–ì–î–ê 5 —ç–ª–µ–º–µ–Ω—Ç–æ–≤ - —Å–∫–æ–ª—å–∫–æ —Ç—Ä–µ–±—É–µ—Ç—Å—è
	// –∫—É–ø–∏—Ç—å –∫–∞–∂–¥–æ–≥–æ –ø—Ä–æ–¥—É–∫—Ç–∞ –¥–ª—è —Å–∫–∏–¥–∫–∏
	vector<int> amounts;
	int cost;
};

int main()
{
	ifstream in{ "discount.in" };
	ofstream out{ "discount.out" };

	// –¥–∞ –ø—Ä–æ—Å—Ç–∏—Ç –º–µ–Ω—è –≥–æ—Å–ø–æ–¥—å
	// –∑–¥–µ—Å—å –±—É–¥–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å—Å—è –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Ü–µ–Ω–∞ –ø—Ä–∏ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–º –Ω–∞–±–æ—Ä–µ –ø—Ä–æ–¥—É–∫—Ç–æ–≤, –Ω–∞–ø—Ä–∏–º–µ—Ä
	// dp[1][0][0][0][0] - –º—ã –∫—É–ø–∏–ª–∏ —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —ç–∫–∑–µ–º–ø–ª—è—Ä –ø–µ—Ä–≤–æ–≥–æ –ø—Ä–æ–¥—É–∫—Ç–∞ –∏ –Ω–∏—á–µ–≥–æ –±–æ–ª—å—à–µ
	// dp[5][5][5][5][5] - —Å–∫—É–ø–∏–ª–∏ –≤–µ—Å—å –º–∞–≥–∞–∑–∏–Ω üòé
	V<V<V<V<V<int>>>>> dp(6, V<V<V<V<int>>>>(6, V<V<V<int>>>(6, V<V<int>>(6, V<int>(6, MAX)))));

	int b;
	in >> b;
	vector<Product> products(5, Product{});
	unordered_map<int, int> remap;
	for (int i = 0; i < b; i++) {
		in >> products[i].id >> products[i].amount >> products[i].cost;
		remap[products[i].id] = i; // –Ω–µ—É–¥–æ–±–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–∞—Å—Ç–æ—è—â–∏–π id –ø—Ä–æ–¥—É–∫—Ç–∞ (1 <= id <= 999),
								   // –ø–æ—ç—Ç–æ–º—É –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –∏–Ω–¥–µ–∫—Å, –≤ –∫–∞–∫–æ–º –ø–æ—Ä—è–¥–∫–µ –º—ã –ø—Ä–æ—á–∏—Ç–∞–ª–∏ –ø—Ä–æ–¥—É–∫—Ç, —Ç.–µ. 7 -> 0, 8 -> 1
								   // 
		// –∑–∞–¥–∞—ë–º –∏–Ω–¥–≤–∏–¥—É–∞–ª—å–Ω—É—é —Ü–µ–Ω—É –ø—Ä–æ–¥—É–∫—Ç–∞
		// –º–∏–Ω–∏-–ø—Ä–∏—ë–º —Å (i == num): –µ—Å–ª–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä, —ç—Ç–æ—Ç –ø—Ä–æ–¥—É–∫—Ç –ø–µ—Ä–≤—ã–π, —Ç–æ –ø–æ–ª—É—á–∏—Ç—Å—è dp[1][0][0][0][0] –∏ —Ç.–¥.
		dp[i == 0][i == 1][i == 2][i == 3][i == 4] = products[i].cost;
	}

	int s;
	in >> s;
	vector<Sale> sales(s, Sale{});
	for (int i = 0; i < s; i++) {
		int n;
		in >> n;

		// –¥–∞–∂–µ –µ—Å–ª–∏ –ø—Ä–æ–¥—É–∫—Ç–æ–≤ –º–µ–Ω—å—à–µ 5, –∑–¥–µ—Å—å –≤—Å—ë —Ä–∞–≤–Ω–æ 5,
		// —Ç.–∫. –ø–æ—Ç–æ–º –≤ –º–∞—Ç—Ä–∏—Ü–µ —ç—Ç–æ —É—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è
		vector<int> amounts = vector<int>(5, 0);
		for (int j = 0; j < n; j++) {
			int id, amount;
			in >> id >> amount;
			amounts[remap[id]] = amount;
		}

		in >> sales[i].cost;
		// —Ç–∞–∫–∏–º –∂–µ –æ–±—Ä–∞–∑–æ–º –∑–∞–¥–∞—ë–º —Ü–µ–Ω—É –¥–ª—è –≤—Å–µ–≥–æ –Ω–∞–±–æ—Ä–∞
		dp[amounts[0]][amounts[1]][amounts[2]][amounts[3]][amounts[4]] = sales[i].cost;
		sales[i].amounts = vector<int>(move(amounts));
	}

	// –Ω–∏—á–µ–≥–æ –Ω–µ –∫—É–ø–∏–ª–∏ :(
	dp[0][0][0][0][0] = 0;

	// —Å—á–∏—Ç–∞–µ–º –º–∞—Ç—Ä–∏—Ü—É –¥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∫–æ–≥–¥–∞ –º—ã –∫—É–ø–∏–ª–∏ –Ω—É–∂–Ω–æ–µ –∫–æ–ª-–≤–æ –ø—Ä–æ–¥—É–∫—Ç–æ–≤
	FOR(p1, PAMOUNT(0)) {
		FOR(p2, PAMOUNT(1)) {
			FOR(p3, PAMOUNT(2)) {
				FOR(p4, PAMOUNT(3)) {
					FOR(p5, PAMOUNT(4)) {
						// –µ—Å—Ç—å –ª–∏ —Å–º—ã—Å–ª –≤–æ–æ–±—â–µ —Å—á–∏—Ç–∞—Ç—å –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ –Ω–∞–±–æ—Ä–∞ —Å—Ç–æ–∏–º–æ—Å—Ç—å?
						// (–º—ã –Ω–∞—á–∏–Ω–∞–µ–º —Å—á–∏—Ç–∞—Ç—å —Å –ø–æ–∑–∏—Ü–∏–∏ dp[0][0][0][0][0] –∏ –º—ã –≤—Ä—è–¥ –ª–∏ —Å—é–¥–∞ –ø–æ–ø–∞–¥—ë–º, –Ω–æ –≤—Å—ë –∂–µ)
						if (dp[p1][p2][p3][p4][p5] == MAX) continue;

						// —Å–Ω–∞—á–∞–ª–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø—Ä–æ–¥—É–∫—Ç–∞ –ø—Ä–æ—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é, –µ—Å–ª–∏ –º—ã –¥–æ–∫—É–ø–∏–º
						// –µ—â—ë –æ–¥–∏–Ω —ç–∫–∑–µ–º–ø–ª—è—Ä —ç—Ç–æ–≥–æ –ø—Ä–æ–¥—É–∫—Ç–∞, –Ω–∞–ø—Ä–∏–º–µ—Ä –¥–ª—è dp[0][0][0][0][0]
						// –µ—Å–ª–∏ –º—ã –ø—ã—Ç–∞–µ–º—Å—è –∫—É–ø–∏—Ç—å 1—ã–π –ø—Ä–æ–¥—É–∫—Ç, —Ç–æ –º—ã —Ö–æ—Ç–∏–º –ø—Ä–æ—Å—á–∏—Ç–∞—Ç—å dp[1][0][0][0][0]
						for (int i = 0; i < b; i++) {
							int p1n = p1 + (i == 0), p2n = p2 + (i == 1), p3n = p3 + (i == 2),
								p4n = p4 + (i == 3), p5n = p5 + (i == 4);
							if (p1n > 5 || p2n > 5 || p3n > 5 || p4n > 5 || p5n > 5) continue;
							dp[p1n][p2n][p3n][p4n][p5n] = min(dp[p1n][p2n][p3n][p4n][p5n], dp[p1][p2][p3][p4][p5] + products[i].cost);
						}
						
						// —Ç–µ–ø–µ—Ä—å –ø—ã—Ç–∞–µ–º—Å—è –ø—Ä–æ—Å—á–∏—Ç–∞—Ç—å –¥–ª—è –∫–∞–∂–¥–æ–π –∞–∫—Ü–∏–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä –¥–ª—è –ø–µ—Ä–≤–æ–≥–æ —Ç–µ—Å—Ç–∞
						// –∏–∑ dp[0][0][0][0][0] –≤ dp[1][2][0][0][0] (—Å—Ç–∞–Ω–µ—Ç 10 –≤–º–µ—Å—Ç–æ 1 * 2 + 2 * 5 = 12)
						for (int i = 0; i < s; i++) {
							int p1n = p1 + SAMOUNT(0), p2n = p2 + SAMOUNT(1), p3n = p3 + SAMOUNT(2),
								p4n = p4 + SAMOUNT(3), p5n = p5 + SAMOUNT(4);
							if (p1n > 5 || p2n > 5 || p3n > 5 || p4n > 5 || p5n > 5) continue;
							dp[p1n][p2n][p3n][p4n][p5n] = min(dp[p1n][p2n][p3n][p4n][p5n], dp[p1][p2][p3][p4][p5] + sales[i].cost);
						}
					}
				}
			}
		}
	}

	out << dp[PAMOUNT(0)][PAMOUNT(1)][PAMOUNT(2)][PAMOUNT(3)][PAMOUNT(4)] << endl;
}
